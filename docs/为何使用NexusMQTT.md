# NexusMQTT 功能与使用全景介绍

面向物联网开发和后端联调的现场，MQTT 客户端早就不是“能连上就行”的小工具，而是每天要盯着看的生产力工具。NexusMQTT 做的事情很简单：把一个人手里零散的连接、主题、脚本、历史数据，重新收束成一个有组织的“工作台”，让你在复杂环境里少犯错、多看清楚。

## 一、这款工具到底解决什么问题？

传统 MQTT 客户端，大多有几个共性：

- 以“单连接”为中心，一次只操作一个连接，改完就关。
- 主题订阅临时写，发完消息就丢，缺乏结构化管理。
- 消息历史很弱，要么只存内存，要么导出能力有限。
- 多环境（本地 / 测试 / 生产）切换全靠手工改配置，容易搞混。

在这样的前提下，当系统一旦复杂起来——几十个主题、多个 Broker、多人协作、长时间联调——就会出现几个典型痛点：

- 连接配置散落各处，很难形成“团队共享的标准工作区”。
- 主题说明只写在脑子里或 wiki 上，客户端里看不到上下文。
- 回溯问题时，找不到完整消息轨迹或导出数据成本很高。
- 想做一点自动压测或持续发布，只能自己写脚本。

**NexusMQTT 的根本目标，是把这些零散的操作，提升到“工作区级别”的资产管理**：

- 连接、Broker、身份、主题目录、历史记录、AI 配置，全都在一个统一工作区里管理。
- 工具本身变成整个团队的“MQTT 调试控制台”，而不是某个工程师桌面上的一次性工具。

## 二、核心功能一览：从连接到主题的完整闭环

### 1. 多连接工作区与集中配置

- 在一个窗口里管理多条 MQTT 连接，按环境或业务分组，支持搜索和一键复制。
- Broker 与身份信息集中托管：
  - Broker 负责协议 / 主机 / 端口 / 挂载路径；
  - 身份负责用户名 / 密码 / 固定 Client ID；
  - 连接只需要“引用”这些资产，减少重复配置。
- 在侧边栏通过右键或快捷键（Ctrl/Cmd + C / V）快速复制连接，连带其主题目录一并复制，避免重新建模。

### 2. 主题工作台：把主题当“文档对象”来管理

NexusMQTT 的差异化，几乎都体现在 **Topic Workbench（主题工作台）** 上：

- 用“目录”的方式管理某条连接下的所有主题：
  - 主题字符串、显示名称、QoS、是否保留、方向（发布 / 订阅 / 双向）；
  - Content-Type、标签、描述等元信息；
  - 对应的 JSON Schema（可选）。
- 为每个主题维护：
  - **载荷模板**：团队达成共识后的标准结构；
  - **示例载荷**：调试时最常用的典型消息。
- 联调阶段，可以直接在工作台上：
  - 订阅 / 取消订阅单个主题；
  - 用模板或示例一键发布消息；
  - 配置自动定时发布任务：
    - 持续运行，手动停止；
    - 固定次数后停止；
    - 在某个时间点自动结束（支持 +2 / +5 分钟等快速选项）。
- 整个主题目录支持按连接导入 / 导出为 JSON 文件，便于在团队之间共享，也方便做 Git 版本管理。

这个设计的本质，是把主题从“命令行参数”提升为“可版本化的资产”，让 MQTT 的使用方式更接近接口文档和 API 管理。

### 3. 消息日志与历史：把一次性流量变成可回溯数据

对于真实系统联调，单看“当前几条消息”是不够的，你更关心的是：过去一段时间里发生了什么。NexusMQTT 在这块做了完整闭环：

- **消息日志面板**：
  - 入站 / 出站方向、QoS、保留标记、时间戳、主题、载荷一目了然；
  - 主题颜色继承自订阅配置，一眼能看出哪条消息来自哪个订阅；
  - 支持对订阅（含通配符）进行静音，过滤掉噪音流量。
- **历史记录管理**（桌面模式基于本地 SQLite）：
  - 向上滚动时自动加载更早的历史，而不是只保留当前页面；
  - 支持按主题或载荷关键字过滤，配合暂停自动滚动查看具体片段；
  - 可以清空当前连接的视图与持久化历史，控制数据体积。
- **导出能力**：
  - 按连接导出 NDJSON 或 CSV，方便导入其他日志系统或用脚本分析；
  - 对接团队已有的数据分析工具，而不是被客户端本身所锁死。

### 4. AI 载荷生成：把“拍脑袋造 JSON”交给模型

在很多团队里，写 MQTT 载荷是高度重复且容易出错的工作。NexusMQTT 内置了 **兼容 OpenAI 的 AI 接口**：

- 在设置中配置 Base URL、API Key、模型名称即可对接现有模型服务。
- 在主题工作台中，对任意主题点击“AI 生成”，就可以生成一份合理的 JSON 载荷模板。
- Rust 后端基于 `rig-core` 做了严格处理，只接受合法 JSON，前端拿到的永远是可用结构，而不是一堆半结构化文本。

这并不是追逐“AI 概念”，而是非常务实地把一个低价值、易出错的环节交给机器，把人力留在业务逻辑和协议设计上。

### 5. 配置导入 / 导出与多平台运行

- 工作区的所有状态——连接、Broker、身份、AI 配置、主题目录、界面偏好——都以本地配置和 SQLite 的形式存储。
- 在设置中可以：
  - 一键导出完整配置为 JSON 备份；
  - 从备份 JSON 恢复整个工作区，迁移到新机器或新环境。
- 同时支持：
  - 纯 Web 模式：适合临时调试或后端 / 前端工程师快速接入；
  - Tauri 桌面模式：启用本地历史数据库与原生对话框，更适合长期使用的主力工作台。

## 三、典型使用场景

### 场景 1：多环境联调与回归验证

- 为本地、测试、预生产、生产分别建连接与分组；
- 共享一套 Broker 与身份配置，减少配置漂移；
- 使用主题工作台维护公共主题目录，在不同环境间切换只改连接，不改主题；
- 出问题时，直接从历史中导出某一时间段的消息，交给后端或数据分析同事复盘。

### 场景 2：协议设计与团队协作

- 在主题工作台中，把每个主题的方向、载荷模板、示例、Schema 维护成“活文档”；
- 用导入 / 导出 JSON 的方式把主题目录纳入仓库管理，配合代码评审；
- 新人只需要把这份目录导入到自己的 NexusMQTT，就能马上用统一的视图联调，而不是各自抄配置。

### 场景 3：自动化发布与轻量压测

- 对关键主题配置自动定时发布任务，用固定间隔或固定次数模拟一定负载；
- 配合本地历史记录和导出数据，观察系统在一段时间内的响应行为；
- 不必为简单场景额外维护一套脚本或压力测试工程。

## 四、适合谁来用？

从定位上看，NexusMQTT 更适合作为以下角色的“日常工作台”：

- **物联网 / 后端工程师**：日常联调业务消息、回溯历史、验证协议演进；
- **测试工程师**：用主题目录和自动发布替代手工脚本，沉淀可复用用例；
- **运维 / SRE**：在现场问题排查时，快速拉起历史消息和导出数据，与监控系统交叉验证；
- **团队负责人 / 架构师**：把 MQTT 相关资产从个人工具迁移到团队可共享、可备份的工作区。

如果你只是不定期发两条消息做 Demo，任何轻量客户端都足够；
如果你每天都在和 MQTT 打交道，NexusMQTT 更像是一块长期投资——把时间花在建立一套工作区上，之后每一次联调、回归、压测都会受益。

## 五、结语

NexusMQTT 不是要“重新发明 MQTT 客户端”，而是承认一个简单事实：当前的 MQTT 使用场景，已经远远超出了早期轻量工具的设计边界。它做的，是把连接、主题、历史、AI 生成和配置管理整合为一个有组织的工作区，让你在复杂系统面前少一点手忙脚乱，多一点可控与确定性。
